{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"hello","title":"hello"},{"location":"#hello","text":"","title":"hello"},{"location":"Gazebo/gazebo/","text":"Getting Started Note note example ardupilot plugin link: ardupilot_gazebo sudo apt install gazebo11","title":"Getting Started"},{"location":"Gazebo/gazebo/#getting-started","text":"Note note example","title":"Getting Started"},{"location":"Gazebo/gazebo/#ardupilot-plugin","text":"link: ardupilot_gazebo sudo apt install gazebo11","title":"ardupilot plugin"},{"location":"MkDocs/configuration/","text":"Configure Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. mkdocs.yml - file example site_name: OK Notebook site_url: https://ori-kruk.github.io/ # must have the trailing slash theme: name: material features: - navigation.instant - navigation.tracking - navigation.tabs - navigation.sections markdown_extensions: - admonition - pymdownx.details - pymdownx.superfences - pymdownx.highlight: anchor_linenums: true - pymdownx.inlinehilite - pymdownx.snippets - pymdownx.superfences","title":"Configure"},{"location":"MkDocs/configuration/#configure","text":"","title":"Configure"},{"location":"MkDocs/configuration/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"MkDocs/configuration/#mkdocsyml-file-example","text":"site_name: OK Notebook site_url: https://ori-kruk.github.io/ # must have the trailing slash theme: name: material features: - navigation.instant - navigation.tracking - navigation.tabs - navigation.sections markdown_extensions: - admonition - pymdownx.details - pymdownx.superfences - pymdownx.highlight: anchor_linenums: true - pymdownx.inlinehilite - pymdownx.snippets - pymdownx.superfences","title":"mkdocs.yml - file example"},{"location":"MkDocs/extensions/","text":"Material for MkDocs For full documentation visit mkdocs-material pip install mkdocs-material","title":"Extensions"},{"location":"MkDocs/extensions/#material-for-mkdocs","text":"For full documentation visit mkdocs-material pip install mkdocs-material","title":"Material for MkDocs"},{"location":"MkDocs/installation/","text":"Getting Start For full documentation visit mkdocs.org install pip install mkdocs Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs gh-deploy - Deploy your documentation to GitHub Pages. mkdocs -h - Print help message and exit.","title":"Getting Start"},{"location":"MkDocs/installation/#getting-start","text":"For full documentation visit mkdocs.org","title":"Getting Start"},{"location":"MkDocs/installation/#install","text":"pip install mkdocs","title":"install"},{"location":"MkDocs/installation/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs gh-deploy - Deploy your documentation to GitHub Pages. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"ROS2/actions/","text":"Actions What is an Actions ? Actions are very similar to services. When you call an Action, you are calling functionality that another node is providing. Also, Actions are based on a Client-Server model - the same as with Services. However, there are two main differences between Actions and Services: Actions are preemptable. This means that you can cancel an Action while it is being executed. Second, Actions provide feedback. This means that, while the Action is being executed, the Server can send feedback back to the Client. As you can see from the graph above, Actions use Services for handling the goal and the result and use Topics to handle the feedback. The node that provides the Action functionality has to contain an Action Server. The Action Server allows other nodes to call that Action functionality. The node that calls to the Action functionality has to contain an Action Client. The Action Client allows a node to connect to the Action Server of nother node. In summarizing, the workflow goes like this: The Client sends a goal to the Server. This will trigger the \"start\" of the Action. The Server sends feedback to the Client meanwhile the Action is taking place. Once the Action finishes, the Server returns a response to the Client. Basic commands ros2 action list ros2 action info <action_name> ros2 action info <action_name> -t the '-t' tells us what interface the action use, the information is in the form: <pkg_name>/action/<interface_name> more data about the interface: ros2 interface show <pkg_name>/action/<interface_name> - call an action: ros2 action send_goal <action_name> <action_type> <values> - call it with a feedback vizualization: ros2 action send_goal -f <action_name> <action_type> <values> Action Client (example) ros2 pkg create my_action_client --build-type ament_python --dependencies rclpy rclpy.action t3_action_msg Inside the my_action_client folder, create a new Python file named action_client.py. Then, you can paste the code below into the script import rclpy from rclpy.action import ActionClient from rclpy.node import Node from t3_action_msg.action import Move class MyActionClient ( Node ): def __init__ ( self ): super () . __init__ ( 'my_action_client' ) self . _action_client = ActionClient ( self , Move , 'turtlebot3_as_2' ) def send_goal ( self , seconds ): goal_msg = Move . Goal () goal_msg . secs = seconds self . _action_client . wait_for_server () self . _send_goal_future = self . _action_client . send_goal_async ( goal_msg , feedback_callback = self . feedback_callback ) self . _send_goal_future . add_done_callback ( self . goal_response_callback ) def goal_response_callback ( self , future ): goal_handle = future . result () if not goal_handle . accepted : self . get_logger () . info ( 'Goal rejected :(' ) return self . get_logger () . info ( 'Goal accepted :)' ) self . _get_result_future = goal_handle . get_result_async () self . _get_result_future . add_done_callback ( self . get_result_callback ) def get_result_callback ( self , future ): result = future . result () . result self . get_logger () . info ( 'Result: {0} ' . format ( result . status )) rclpy . shutdown () def feedback_callback ( self , feedback_msg ): feedback = feedback_msg . feedback self . get_logger () . info ( 'Received feedback: {0} ' . format ( feedback . feedback )) def main ( args = None ): rclpy . init ( args = args ) action_client = MyActionClient () action_client . send_goal ( 5 ) rclpy . spin ( action_client ) if __name__ == '__main__' : main () Modify the setup.py: from setuptools import setup import os from glob import glob package_name = 'my_action_client' setup ( name = 'my_action_client' , version = '0.0.0' , packages = [ package_name ], data_files = [ ( 'share/ament_index/resource_index/packages' , [ 'resource/' + package_name ]), ( 'share/' + package_name , [ 'package.xml' ]), ( os . path . join ( 'share' , package_name ), glob ( 'launch/*.launch.py' )) ], install_requires = [ 'setuptools' ], zip_safe = True , maintainer = 'user' , maintainer_email = 'user@todo.todo' , description = 'TODO: Package description' , license = 'TODO: License declaration' , tests_require = [ 'pytest' ], entry_points = { 'console_scripts' : [ 'example52 = my_action_client.action_client:main' ], }, ) Create a launch file named example52_launch_file.launch.py: from launch import LaunchDescription from launch_ros.actions import Node def generate_launch_description (): return LaunchDescription ([ Node ( package = 'my_action_client' , executable = 'example52' , output = 'screen' ), ]) Compile your package: cd ~/ros2_ws colcon build --packages-select my_action_client source ~/ros2_ws/install/setup.bash Then, launch the Action Server node on your Shell #1. ros2 launch turtlebot3_as action_server.launch.py Finally, launch the Action Client node on your Shell #2. ros2 launch my_action_client example52_launch_file.launch.py Action Server (example) First, create a new package where you will place your Action Server code. ros2 pkg create my_action_server --build-type ament_python --dependencies rclpy rclpy.action t3_action_msg Inside the my_action_server folder, create a new Python file named action_server.py. You can paste the code below into the script: import rclpy from rclpy.action import ActionServer from rclpy.node import Node from t3_action_msg.action import Move from geometry_msgs.msg import Twist import time class MyActionServer ( Node ): def __init__ ( self ): super () . __init__ ( 'my_action_server' ) self . _action_server = ActionServer ( self , Move , 'turtlebot3_as_2' , self . execute_callback ) self . cmd = Twist () self . publisher_ = self . create_publisher ( Twist , 'cmd_vel' , 10 ) def execute_callback ( self , goal_handle ): self . get_logger () . info ( 'Executing goal...' ) feedback_msg = Move . Feedback () feedback_msg . feedback = \"Moving to the left left left...\" for i in range ( 1 , goal_handle . request . secs ): self . get_logger () . info ( 'Feedback: {0} ' . format ( feedback_msg . feedback )) goal_handle . publish_feedback ( feedback_msg ) self . cmd . linear . x = 0.3 self . cmd . angular . z = 0.3 self . publisher_ . publish ( self . cmd ) time . sleep ( 1 ) goal_handle . succeed () self . cmd . linear . x = 0.0 self . cmd . angular . z = 0.0 self . publisher_ . publish ( self . cmd ) result = Move . Result () result . status = \"Finished action server. Robot moved during 5 seconds\" self . get_logger () . info ( 'Result: {0} ' . format ( result . status )) return result def main ( args = None ): rclpy . init ( args = args ) my_action_server = MyActionServer () rclpy . spin ( my_action_server ) if __name__ == '__main__' : main () Modify the setup.py file: from setuptools import setup import os from glob import glob package_name = 'my_action_server' setup ( name = 'my_action_server' , version = '0.0.0' , packages = [ package_name ], data_files = [ ( 'share/ament_index/resource_index/packages' , [ 'resource/' + package_name ]), ( 'share/' + package_name , [ 'package.xml' ]), ( os . path . join ( 'share' , package_name ), glob ( 'launch/*.launch.py' )) ], install_requires = [ 'setuptools' ], zip_safe = True , maintainer = 'user' , maintainer_email = 'user@todo.todo' , description = 'TODO: Package description' , license = 'TODO: License declaration' , tests_require = [ 'pytest' ], entry_points = { 'console_scripts' : [ 'example53 = my_action_server.action_server:main' ], }, ) Create a launch file named example53_launch_file.launch.py: from launch import LaunchDescription from launch_ros.actions import Node def generate_launch_description (): return LaunchDescription ([ Node ( package = 'my_action_server' , executable = 'example53' , output = 'screen' ), ]) Compile your package: cd ~/ros2_ws colcon build --packages-select my_action_server source ~/ros2_ws/install/setup.bash After compiling, launch the action server node on your Shell #1. ros2 launch my_action_server example53_launch_file.launch.py Create an Action Interface 1- Create an Action directory in your custom_interface package. 2- Create your .action Action Interface file. - Remember that the Action Interface file has to contain three parts, each separated by three hyphens. #goal message_type goal_var_name --- #result message_type result_var_name --- #feedback message_type feedback_var_name for example Move.action should be like the following: int32 secs --- string status --- string feedback 3- Modify the CMakeLists.txt and package.xml files to include action interface compilation. Read the detailed description below. - Modification of CMakeLists.txt rosidl_generate_interfaces ( ${ PROJECT_NAME } \"action/Move.action\" ) find_package ( action_msgs REQUIRED ) - Modification of package.xml <depend>action_msgs</depend> Finally, when everything is correctly set up, compile it: cd ~/ros2_ws colcon build --packages-select custom_interfaces source install/setup.bash To verify that your Action Interface has been created correctly, use the following command: ros2 interface show custom_interfaces/action/Move","title":"Actions"},{"location":"ROS2/actions/#actions","text":"","title":"Actions"},{"location":"ROS2/actions/#what-is-an-actions","text":"Actions are very similar to services. When you call an Action, you are calling functionality that another node is providing. Also, Actions are based on a Client-Server model - the same as with Services. However, there are two main differences between Actions and Services: Actions are preemptable. This means that you can cancel an Action while it is being executed. Second, Actions provide feedback. This means that, while the Action is being executed, the Server can send feedback back to the Client. As you can see from the graph above, Actions use Services for handling the goal and the result and use Topics to handle the feedback. The node that provides the Action functionality has to contain an Action Server. The Action Server allows other nodes to call that Action functionality. The node that calls to the Action functionality has to contain an Action Client. The Action Client allows a node to connect to the Action Server of nother node. In summarizing, the workflow goes like this: The Client sends a goal to the Server. This will trigger the \"start\" of the Action. The Server sends feedback to the Client meanwhile the Action is taking place. Once the Action finishes, the Server returns a response to the Client.","title":"What is an Actions ?"},{"location":"ROS2/actions/#basic-commands","text":"ros2 action list ros2 action info <action_name> ros2 action info <action_name> -t the '-t' tells us what interface the action use, the information is in the form: <pkg_name>/action/<interface_name> more data about the interface: ros2 interface show <pkg_name>/action/<interface_name> - call an action: ros2 action send_goal <action_name> <action_type> <values> - call it with a feedback vizualization: ros2 action send_goal -f <action_name> <action_type> <values>","title":"Basic commands"},{"location":"ROS2/actions/#action-client-example","text":"ros2 pkg create my_action_client --build-type ament_python --dependencies rclpy rclpy.action t3_action_msg Inside the my_action_client folder, create a new Python file named action_client.py. Then, you can paste the code below into the script import rclpy from rclpy.action import ActionClient from rclpy.node import Node from t3_action_msg.action import Move class MyActionClient ( Node ): def __init__ ( self ): super () . __init__ ( 'my_action_client' ) self . _action_client = ActionClient ( self , Move , 'turtlebot3_as_2' ) def send_goal ( self , seconds ): goal_msg = Move . Goal () goal_msg . secs = seconds self . _action_client . wait_for_server () self . _send_goal_future = self . _action_client . send_goal_async ( goal_msg , feedback_callback = self . feedback_callback ) self . _send_goal_future . add_done_callback ( self . goal_response_callback ) def goal_response_callback ( self , future ): goal_handle = future . result () if not goal_handle . accepted : self . get_logger () . info ( 'Goal rejected :(' ) return self . get_logger () . info ( 'Goal accepted :)' ) self . _get_result_future = goal_handle . get_result_async () self . _get_result_future . add_done_callback ( self . get_result_callback ) def get_result_callback ( self , future ): result = future . result () . result self . get_logger () . info ( 'Result: {0} ' . format ( result . status )) rclpy . shutdown () def feedback_callback ( self , feedback_msg ): feedback = feedback_msg . feedback self . get_logger () . info ( 'Received feedback: {0} ' . format ( feedback . feedback )) def main ( args = None ): rclpy . init ( args = args ) action_client = MyActionClient () action_client . send_goal ( 5 ) rclpy . spin ( action_client ) if __name__ == '__main__' : main () Modify the setup.py: from setuptools import setup import os from glob import glob package_name = 'my_action_client' setup ( name = 'my_action_client' , version = '0.0.0' , packages = [ package_name ], data_files = [ ( 'share/ament_index/resource_index/packages' , [ 'resource/' + package_name ]), ( 'share/' + package_name , [ 'package.xml' ]), ( os . path . join ( 'share' , package_name ), glob ( 'launch/*.launch.py' )) ], install_requires = [ 'setuptools' ], zip_safe = True , maintainer = 'user' , maintainer_email = 'user@todo.todo' , description = 'TODO: Package description' , license = 'TODO: License declaration' , tests_require = [ 'pytest' ], entry_points = { 'console_scripts' : [ 'example52 = my_action_client.action_client:main' ], }, ) Create a launch file named example52_launch_file.launch.py: from launch import LaunchDescription from launch_ros.actions import Node def generate_launch_description (): return LaunchDescription ([ Node ( package = 'my_action_client' , executable = 'example52' , output = 'screen' ), ]) Compile your package: cd ~/ros2_ws colcon build --packages-select my_action_client source ~/ros2_ws/install/setup.bash Then, launch the Action Server node on your Shell #1. ros2 launch turtlebot3_as action_server.launch.py Finally, launch the Action Client node on your Shell #2. ros2 launch my_action_client example52_launch_file.launch.py","title":"Action Client (example)"},{"location":"ROS2/actions/#action-server-example","text":"First, create a new package where you will place your Action Server code. ros2 pkg create my_action_server --build-type ament_python --dependencies rclpy rclpy.action t3_action_msg Inside the my_action_server folder, create a new Python file named action_server.py. You can paste the code below into the script: import rclpy from rclpy.action import ActionServer from rclpy.node import Node from t3_action_msg.action import Move from geometry_msgs.msg import Twist import time class MyActionServer ( Node ): def __init__ ( self ): super () . __init__ ( 'my_action_server' ) self . _action_server = ActionServer ( self , Move , 'turtlebot3_as_2' , self . execute_callback ) self . cmd = Twist () self . publisher_ = self . create_publisher ( Twist , 'cmd_vel' , 10 ) def execute_callback ( self , goal_handle ): self . get_logger () . info ( 'Executing goal...' ) feedback_msg = Move . Feedback () feedback_msg . feedback = \"Moving to the left left left...\" for i in range ( 1 , goal_handle . request . secs ): self . get_logger () . info ( 'Feedback: {0} ' . format ( feedback_msg . feedback )) goal_handle . publish_feedback ( feedback_msg ) self . cmd . linear . x = 0.3 self . cmd . angular . z = 0.3 self . publisher_ . publish ( self . cmd ) time . sleep ( 1 ) goal_handle . succeed () self . cmd . linear . x = 0.0 self . cmd . angular . z = 0.0 self . publisher_ . publish ( self . cmd ) result = Move . Result () result . status = \"Finished action server. Robot moved during 5 seconds\" self . get_logger () . info ( 'Result: {0} ' . format ( result . status )) return result def main ( args = None ): rclpy . init ( args = args ) my_action_server = MyActionServer () rclpy . spin ( my_action_server ) if __name__ == '__main__' : main () Modify the setup.py file: from setuptools import setup import os from glob import glob package_name = 'my_action_server' setup ( name = 'my_action_server' , version = '0.0.0' , packages = [ package_name ], data_files = [ ( 'share/ament_index/resource_index/packages' , [ 'resource/' + package_name ]), ( 'share/' + package_name , [ 'package.xml' ]), ( os . path . join ( 'share' , package_name ), glob ( 'launch/*.launch.py' )) ], install_requires = [ 'setuptools' ], zip_safe = True , maintainer = 'user' , maintainer_email = 'user@todo.todo' , description = 'TODO: Package description' , license = 'TODO: License declaration' , tests_require = [ 'pytest' ], entry_points = { 'console_scripts' : [ 'example53 = my_action_server.action_server:main' ], }, ) Create a launch file named example53_launch_file.launch.py: from launch import LaunchDescription from launch_ros.actions import Node def generate_launch_description (): return LaunchDescription ([ Node ( package = 'my_action_server' , executable = 'example53' , output = 'screen' ), ]) Compile your package: cd ~/ros2_ws colcon build --packages-select my_action_server source ~/ros2_ws/install/setup.bash After compiling, launch the action server node on your Shell #1. ros2 launch my_action_server example53_launch_file.launch.py","title":"Action Server (example)"},{"location":"ROS2/actions/#create-an-action-interface","text":"1- Create an Action directory in your custom_interface package. 2- Create your .action Action Interface file. - Remember that the Action Interface file has to contain three parts, each separated by three hyphens. #goal message_type goal_var_name --- #result message_type result_var_name --- #feedback message_type feedback_var_name for example Move.action should be like the following: int32 secs --- string status --- string feedback 3- Modify the CMakeLists.txt and package.xml files to include action interface compilation. Read the detailed description below. - Modification of CMakeLists.txt rosidl_generate_interfaces ( ${ PROJECT_NAME } \"action/Move.action\" ) find_package ( action_msgs REQUIRED ) - Modification of package.xml <depend>action_msgs</depend> Finally, when everything is correctly set up, compile it: cd ~/ros2_ws colcon build --packages-select custom_interfaces source install/setup.bash To verify that your Action Interface has been created correctly, use the following command: ros2 interface show custom_interfaces/action/Move","title":"Create an Action Interface"},{"location":"ROS2/basic/","text":"Basic programs. You can think of a package as all the files that a specific ROS2 program contains; all its CPP files, Python files, configuration files, compilation files, launch files, and parameters files. Every Python package will have the following structure of files and folders: package.xml - File containing meta-information about the package (maintainer of the package, dependencies, etc.). setup.py - File containing instructions for how to compile the package. setup.cfg - File that defines where the scripts will be installed. / - This directory will always have the same name as your package. You will put all your Python scripts inside this folder. Note that it already contains an empty init .py file. Some packages might contain extra folders. For instance, the launch folder contains the package's launch files create python package source /opt/ros/galactic/setup.bash cd ~/ros2_ws/src ros2 pkg create --build-type ament_python my_package --dependencies rclpy build a packages cd ~/ros2_ws colcon build specific package colcon build --packages-select my_package source install/setup.bash build basic node simple.py in 'src/my_package/my_package' import rclpy from rclpy.node import Node class MyNode ( Node ): def __init__ ( self ): node_name = \"basic_node\" super () . __init__ ( node_name ) self . get_logger () . info ( f \" { node_name } is running...\" ) self . create_timer ( 0.2 , self . timer_callback ) def timer_callback ( self ): self . get_logger () . info ( f \" { node_name } is alive\" ) def main ( args = None ): rclpy . init ( args = args ) node = MyNode () rclpy . spin ( node ) node . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main () build launch file create a launch file cd ~/ros2_ws/src/my_package mkdir launch cd ~/ros2_ws/src/my_package/launch touch my_package_launch_file.launch.py chmod +x my_package_launch_file.launch.py file context from launch import LaunchDescription from launch_ros.actions import Node def generate_launch_description (): return LaunchDescription ([ Node ( package = 'my_package' , executable = 'simple_node' , output = 'screen' ), ]) modifying the setup.py add info to the data_files & entry_points from setuptools import setup import os from glob import glob package_name = 'my_package' setup ( name = package_name , version = '0.0.0' , packages = [ package_name ], data_files = [ ( 'share/ament_index/resource_index/packages' , [ 'resource/' + package_name ]), ( 'share/' + package_name , [ 'package.xml' ]), ( os . path . join ( 'share' , package_name ), glob ( 'launch/*.launch.py' )) ], install_requires = [ 'setuptools' ], zip_safe = True , maintainer = 'somebody very awesome' , maintainer_email = 'user@user.com' , description = 'TODO: Package description' , license = 'TODO: License declaration' , tests_require = [ 'pytest' ], entry_points = { 'console_scripts' : [ 'simple_node = my_package.simple:main' ], }, ) run a package ros2 run <package_name> <executable_file> run a launch file finally, compile and activate the package, then: ros2 launch my_package my_package_launch_file.launch.py","title":"Basic"},{"location":"ROS2/basic/#basic","text":"programs. You can think of a package as all the files that a specific ROS2 program contains; all its CPP files, Python files, configuration files, compilation files, launch files, and parameters files. Every Python package will have the following structure of files and folders: package.xml - File containing meta-information about the package (maintainer of the package, dependencies, etc.). setup.py - File containing instructions for how to compile the package. setup.cfg - File that defines where the scripts will be installed. / - This directory will always have the same name as your package. You will put all your Python scripts inside this folder. Note that it already contains an empty init .py file. Some packages might contain extra folders. For instance, the launch folder contains the package's launch files","title":"Basic"},{"location":"ROS2/basic/#create-python-package","text":"source /opt/ros/galactic/setup.bash cd ~/ros2_ws/src ros2 pkg create --build-type ament_python my_package --dependencies rclpy","title":"create python package"},{"location":"ROS2/basic/#build-a-packages","text":"cd ~/ros2_ws colcon build","title":"build a packages"},{"location":"ROS2/basic/#specific-package","text":"colcon build --packages-select my_package source install/setup.bash","title":"specific package"},{"location":"ROS2/basic/#build-basic-node","text":"simple.py in 'src/my_package/my_package' import rclpy from rclpy.node import Node class MyNode ( Node ): def __init__ ( self ): node_name = \"basic_node\" super () . __init__ ( node_name ) self . get_logger () . info ( f \" { node_name } is running...\" ) self . create_timer ( 0.2 , self . timer_callback ) def timer_callback ( self ): self . get_logger () . info ( f \" { node_name } is alive\" ) def main ( args = None ): rclpy . init ( args = args ) node = MyNode () rclpy . spin ( node ) node . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main ()","title":"build basic node"},{"location":"ROS2/basic/#build-launch-file","text":"","title":"build launch file"},{"location":"ROS2/basic/#create-a-launch-file","text":"cd ~/ros2_ws/src/my_package mkdir launch cd ~/ros2_ws/src/my_package/launch touch my_package_launch_file.launch.py chmod +x my_package_launch_file.launch.py","title":"create a launch file"},{"location":"ROS2/basic/#file-context","text":"from launch import LaunchDescription from launch_ros.actions import Node def generate_launch_description (): return LaunchDescription ([ Node ( package = 'my_package' , executable = 'simple_node' , output = 'screen' ), ])","title":"file context"},{"location":"ROS2/basic/#modifying-the-setuppy","text":"add info to the data_files & entry_points from setuptools import setup import os from glob import glob package_name = 'my_package' setup ( name = package_name , version = '0.0.0' , packages = [ package_name ], data_files = [ ( 'share/ament_index/resource_index/packages' , [ 'resource/' + package_name ]), ( 'share/' + package_name , [ 'package.xml' ]), ( os . path . join ( 'share' , package_name ), glob ( 'launch/*.launch.py' )) ], install_requires = [ 'setuptools' ], zip_safe = True , maintainer = 'somebody very awesome' , maintainer_email = 'user@user.com' , description = 'TODO: Package description' , license = 'TODO: License declaration' , tests_require = [ 'pytest' ], entry_points = { 'console_scripts' : [ 'simple_node = my_package.simple:main' ], }, )","title":"modifying the setup.py"},{"location":"ROS2/basic/#run-a-package","text":"ros2 run <package_name> <executable_file>","title":"run a package"},{"location":"ROS2/basic/#run-a-launch-file","text":"finally, compile and activate the package, then: ros2 launch my_package my_package_launch_file.launch.py","title":"run a launch file"},{"location":"ROS2/courses/","text":"Courses ROS2 Basics in 5 Days (Python) Unit 1 Introduction to the Course Unit 2 Basic Concepts Unit 3 Understanding ROS2 Topics Unit 4 Understanding ROS2 Services Unit 5 Understanding ROS2 Actions Unit 6 ROS2 Debugging Tools","title":"Courses"},{"location":"ROS2/courses/#courses","text":"","title":"Courses"},{"location":"ROS2/courses/#ros2-basics-in-5-days-python","text":"Unit 1 Introduction to the Course Unit 2 Basic Concepts Unit 3 Understanding ROS2 Topics Unit 4 Understanding ROS2 Services Unit 5 Understanding ROS2 Actions Unit 6 ROS2 Debugging Tools","title":"ROS2 Basics in 5 Days (Python)"},{"location":"ROS2/custom_interface/","text":"Custom interface It is always recommended to use the interfaces that ROS2 already provides. Remember you can check all ROS2 available interfaces using the ros2 interface list) command. However, if none fits your needs, you can create a new one. Create a new package named custom_interfaces. This package, however, has to be a CMake package. Currently, there is no way to generate custom interfaces in a pure Python package. However, you can create a custom interface in a CMake package and then use it in a Python node. Create a package with a custom msg cd ~/ros2_ws/src ros2 pkg create --build-type ament_cmake custom_interfaces cd ~/ros2_ws/src/custom_interfaces mkdir msg cd msg touch Age.msg - The file 'Age.msg'will contain the following: int32 year int32 month int32 day Modify the CMakeLists.txt file: cmake_minimum_required ( VERSION 3 .5 ) project ( custom_interfaces ) # Default to C99 if ( NOT CMAKE_C_STANDARD ) set ( CMAKE_C_STANDARD 99 ) endif () # Default to C++14 if ( NOT CMAKE_CXX_STANDARD ) set ( CMAKE_CXX_STANDARD 14 ) endif () if ( CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" ) add_compile_options ( -Wall -Wextra -Wpedantic ) endif () # find dependencies find_package ( ament_cmake REQUIRED ) find_package ( rclcpp REQUIRED ) find_package ( std_msgs REQUIRED ) find_package ( rosidl_default_generators REQUIRED ) if ( BUILD_TESTING ) find_package ( ament_lint_auto REQUIRED ) # the following line skips the linter, which checks for copyrights # remove the line when copyright and license are present in all source files set ( ament_cmake_copyright_FOUND TRUE ) # the following line skips cpplint (only works in a git repo) # remove the line when this package is a git repo set ( ament_cmake_cpplint_FOUND TRUE ) ament_lint_auto_find_test_dependencies () endif () rosidl_generate_interfaces ( ${ PROJECT_NAME } \"msg/Age.msg\" ) ament_package () Modify the package.xml file: <?xml version = \"1.0\" ?> <?xml-model href = \"http://download.ros.org/schema/package_format2.xsd\" schematypens = \"http://www.w3.org/2001/XMLSchema\" ?> <package format = \"3\" > <name>custom_interfaces</name> <version>0.0.0</version> <description>TODO: Package description</description> <maintainer email = \"ubuntu@todo.todo\" >ubuntu</maintainer> <license>TODO: License declaration</license> <buildtool_depend>ament_cmake</buildtool_depend> <depend>rclcpp</depend> <depend>std_msgs</depend> <build_depend>rosidl_default_generators</build_depend> <exec_depend>rosidl_default_runtime</exec_depend> <member_of_group>rosidl_interface_packages</member_of_group> <test_depend>ament_lint_auto</test_depend> <test_depend>ament_lint_common</test_depend> <export> <build_type>ament_cmake</build_type> </export> </package> Compile & Check cd ~/ros2_ws colcon build --packages-select custom_interfaces source install/setup.bash ros2 interface show custom_interfaces/msg/Age Example of a use case: Including ' on_shutdown ' feature import rclpy # import the ROS2 python dependencies from rclpy.node import Node # import the Twist module from geometry_msgs dependencies from geometry_msgs.msg import Twist # import the LaserScan module from sensor_msgs dependencies from sensor_msgs.msg import LaserScan from rclpy.qos import ReliabilityPolicy , QoSProfile from custom_interfaces.msg import Age class Example36 ( Node ): def __init__ ( self ): # Here you have the class constructor # call the class constructor super () . __init__ ( 'example36' ) # create the publisher object self . publisher_ = self . create_publisher ( Twist , 'cmd_vel' , 10 ) # create the subscriber object self . subscriber = self . create_subscription ( LaserScan , '/scan' , self . laser_callback , QoSProfile ( depth = 10 , reliability = ReliabilityPolicy . BEST_EFFORT )) # define the timer period for 0.5 seconds self . timer_period = 0.5 # define the variable to save the received info self . laser_forward = 0 # create a Twist message self . cmd = Twist () self . timer = self . create_timer ( self . timer_period , self . motion ) self . age = Age () def laser_callback ( self , msg ): # Save the frontal laser scan info at 0\u00b0 self . laser_forward = msg . ranges [ 359 ] def motion ( self ): self . get_logger () . info ( 'I receive: \" %s \"' % str ( self . laser_forward )) # Read the first distance until you find a wall if self . laser_forward > 5 : self . cmd . linear . x = 0.5 self . cmd . angular . z = 0.5 # Wall found. It is time to go straight elif self . laser_forward < 5 and self . laser_forward >= 0.5 : self . cmd . linear . x = 0.2 self . cmd . angular . z = 0.0 # be careful if you have to stop. else : self . cmd . linear . x = 0.0 self . cmd . angular . z = 0.0 self . publisher_ . publish ( self . cmd ) def on_shutdown ( self ): self . age . year = 2021 self . age . month = 5 self . age . day = 21 self . get_logger () . info ( 'Date this program was made : %d ' % self . age . day + '/ %d ' % self . age . month + '/ %d ' % self . age . year ) def main ( args = None ): # initialize the ROS communication rclpy . init ( args = args ) # declare the node constructor example36 = Example36 () # pause the program execution, waits for a request to kill the node (ctrl+c) rclpy . get_default_context () . on_shutdown ( example36 . on_shutdown ) try : rclpy . spin ( example36 ) except KeyboardInterrupt : pass # shutdown the ROS communication rclpy . shutdown () if __name__ == '__main__' : main () Create cusom service interface cd ~/ros2_ws/src/custom_interfaces mkdir srv cd srv touch MyCustomServiceMessage.srv - The file 'MyCustomServiceMessage.srv' will contain the following: string move # Signal to define the movement # \"Turn right\" to make the robot turn in the right direction. # \"Turn left\" to make the robot turn in the left direction. # \"Stop\" to make the robot stop the movement. --- bool success # Did it achieve it? - modify CMakeLists.txt & package.xml (like on message example) - build and check for this new interface (show) ros2 interface show custom_interfaces/srv/MyCustomServiceMessage Example of a use case: Create a new package named movement_pkg on your ~/ros2_ws/src directory. cd ~/ros2_ws/src ros2 pkg create --build-type ament_python movement_pkg --dependencies rclpy custom_interfaces std_msgs geometry_msgs sensor_msgs Create two new files named movement_server.py and movement_client.py inside the movement_pkg folder Inside the file movement_server.py, write the following code: # import the Twist module from geometry_msgs messages interface from geometry_msgs.msg import Twist # import the MyCustomServiceMessage module from custom_interfaces_service interface from custom_interfaces.srv import MyCustomServiceMessage # import the ROS2 Python client libraries import rclpy from rclpy.node import Node class Service ( Node ): def __init__ ( self ): # Here you have the class constructor # call the class constructor to initialize the node as service_stop super () . __init__ ( 'movement_server' ) # create the Service Server object # defines the type, name, and callback function self . srv = self . create_service ( MyCustomServiceMessage , 'movement' , self . custom_service_callback ) # create the Publisher object # in this case, the Publisher will publish on /cmd_vel topic with a queue size of 10 messages. # use the Twist module self . publisher_ = self . create_publisher ( Twist , 'cmd_vel' , 10 ) def custom_service_callback ( self , request , response ): # The callback function receives the self-class parameter, # received along with two parameters called request and response # - receive the data by request # - return a result as a response # create a Twist message msg = Twist () if request . move == \"Turn Right\" : # define the linear x-axis velocity of /cmd_vel topic parameter to 0.1 msg . linear . x = 0.1 # define the angular z-axis velocity of /cmd_vel topic parameter to -0.5 to turn right msg . angular . z = - 0.5 # Publish the message to the topic self . publisher_ . publish ( msg ) # print a pretty message self . get_logger () . info ( 'Turning to right direction!!' ) # response state response . success = True elif request . move == \"Turn Left\" : # define the linear x-axis velocity of /cmd_vel topic parameter to 0.1 msg . linear . x = 0.1 # define the angular z-axis velocity of /cmd_vel topic parameter to 0.5 to turn left msg . angular . z = 0.5 # Publish the message to the topic self . publisher_ . publish ( msg ) # print a pretty message self . get_logger () . info ( 'Turning to left direction!!' ) # response state response . success = True elif request . move == \"Stop\" : # define the linear x-axis velocity of /cmd_vel topic parameter to 0 msg . linear . x = 0.0 # define the angular z-axis velocity of /cmd_vel topic parameter to 0 msg . angular . z = 0.0 # Publish the message to the topic self . publisher_ . publish ( msg ) # print a pretty message self . get_logger () . info ( 'Stop there!!' ) # response state response . success = True else : # response state response . success = False # return the response parameter return response def main ( args = None ): # initialize the ROS communication rclpy . init ( args = args ) # declare the node constructor service = Service () # pause the program execution, waits for a request to kill the node (ctrl+c) rclpy . spin ( service ) # shutdown the ROS communication rclpy . shutdown () if __name__ == '__main__' : main () Inside the file movement_client.py write the following code: # import the MyCustomServiceMessage module from custom_interfaces_service interface from custom_interfaces.srv import MyCustomServiceMessage # import the ROS2 Python client libraries import rclpy from rclpy.node import Node import sys class ClientAsync ( Node ): def __init__ ( self ): # Here you have the class constructor # call the class constructor to initialize the node as movement_client super () . __init__ ( 'movement_client' ) # create the Service Client object # defines the name and type of the Service Server you will work with. self . client = self . create_client ( MyCustomServiceMessage , 'movement' ) # checks once per second if a Service matching the type and name of the client is available. while not self . client . wait_for_service ( timeout_sec = 1.0 ): # if it is not available, a message is displayed self . get_logger () . info ( 'service not available, waiting again...' ) # create an Empty request self . req = MyCustomServiceMessage . Request () def send_request ( self ): # send the request self . req . move = sys . argv [ 1 ] # uses sys.argv to access command line input arguments for the request. self . future = self . client . call_async ( self . req ) # to print in the console def main ( args = None ): # initialize the ROS communication rclpy . init ( args = args ) # declare the node constructor client = ClientAsync () # run the send_request() method client . send_request () while rclpy . ok (): # pause the program execution, waits for a request to kill the node (ctrl+c) rclpy . spin_once ( client ) if client . future . done (): try : # checks the future for a response from the Service # while the system is running. # if the Service has sent a response, the result will be written # to a log message. response = client . future . result () except Exception as e : # Display the message on the console client . get_logger () . info ( 'Service call failed %r ' % ( e ,)) else : # Display the message on the console client . get_logger () . info ( 'Response state %r ' % ( response . success ,)) break client . destroy_node () # shutdown the ROS communication rclpy . shutdown () if __name__ == '__main__' : main () Create a launch file named movement_server_launch_file.launch.py to launch the Service Server node you just created. cd ~/ros2_ws/src/movement_pkg mkdir launch cd launch touch movement_server_launch_file.launch.py Inside movement_server_launch_file.launch.py, write the necessary code to launch the executable files of the movement_server script. from launch import LaunchDescription from launch_ros.actions import Node def generate_launch_description (): return LaunchDescription ([ Node ( package = 'movement_pkg' , executable = 'movement_server' , output = 'screen' ), ]) Modify the setup.py from setuptools import setup import os from glob import glob package_name = 'movement_pkg' setup ( name = package_name , version = '0.0.0' , packages = [ package_name ], data_files = [ ( 'share/ament_index/resource_index/packages' , [ 'resource/' + package_name ]), ( 'share/' + package_name , [ 'package.xml' ]), ( os . path . join ( 'share' , package_name ), glob ( 'launch/*.launch.py' )) ], install_requires = [ 'setuptools' ], zip_safe = True , maintainer = 'user' , maintainer_email = 'user@todo.todo' , description = 'TODO: Package description' , license = 'TODO: License declaration' , tests_require = [ 'pytest' ], entry_points = { 'console_scripts' : [ 'movement_server = movement_pkg.movement_server:main' , 'movement_client = movement_pkg.movement_client:main' ], }, ) Compile your package Launch the Service Server ros2 launch movement_pkg movement_server_launch_file.launch.py on a different shell, play with the client: ros2 run movement_pkg movement_client \"Turn Left\" ros2 run movement_pkg movement_client \"Turn Right\" ros2 run movement_pkg movement_client \"Stop\" ros2 run movement_pkg movement_client \"Invalid\"","title":"Custom interface"},{"location":"ROS2/custom_interface/#custom-interface","text":"It is always recommended to use the interfaces that ROS2 already provides. Remember you can check all ROS2 available interfaces using the ros2 interface list) command. However, if none fits your needs, you can create a new one. Create a new package named custom_interfaces. This package, however, has to be a CMake package. Currently, there is no way to generate custom interfaces in a pure Python package. However, you can create a custom interface in a CMake package and then use it in a Python node.","title":"Custom interface"},{"location":"ROS2/custom_interface/#create-a-package-with-a-custom-msg","text":"cd ~/ros2_ws/src ros2 pkg create --build-type ament_cmake custom_interfaces cd ~/ros2_ws/src/custom_interfaces mkdir msg cd msg touch Age.msg - The file 'Age.msg'will contain the following: int32 year int32 month int32 day","title":"Create a package with a custom msg"},{"location":"ROS2/custom_interface/#modify-the-cmakeliststxt-file","text":"cmake_minimum_required ( VERSION 3 .5 ) project ( custom_interfaces ) # Default to C99 if ( NOT CMAKE_C_STANDARD ) set ( CMAKE_C_STANDARD 99 ) endif () # Default to C++14 if ( NOT CMAKE_CXX_STANDARD ) set ( CMAKE_CXX_STANDARD 14 ) endif () if ( CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" ) add_compile_options ( -Wall -Wextra -Wpedantic ) endif () # find dependencies find_package ( ament_cmake REQUIRED ) find_package ( rclcpp REQUIRED ) find_package ( std_msgs REQUIRED ) find_package ( rosidl_default_generators REQUIRED ) if ( BUILD_TESTING ) find_package ( ament_lint_auto REQUIRED ) # the following line skips the linter, which checks for copyrights # remove the line when copyright and license are present in all source files set ( ament_cmake_copyright_FOUND TRUE ) # the following line skips cpplint (only works in a git repo) # remove the line when this package is a git repo set ( ament_cmake_cpplint_FOUND TRUE ) ament_lint_auto_find_test_dependencies () endif () rosidl_generate_interfaces ( ${ PROJECT_NAME } \"msg/Age.msg\" ) ament_package ()","title":"Modify the CMakeLists.txt file:"},{"location":"ROS2/custom_interface/#modify-the-packagexml-file","text":"<?xml version = \"1.0\" ?> <?xml-model href = \"http://download.ros.org/schema/package_format2.xsd\" schematypens = \"http://www.w3.org/2001/XMLSchema\" ?> <package format = \"3\" > <name>custom_interfaces</name> <version>0.0.0</version> <description>TODO: Package description</description> <maintainer email = \"ubuntu@todo.todo\" >ubuntu</maintainer> <license>TODO: License declaration</license> <buildtool_depend>ament_cmake</buildtool_depend> <depend>rclcpp</depend> <depend>std_msgs</depend> <build_depend>rosidl_default_generators</build_depend> <exec_depend>rosidl_default_runtime</exec_depend> <member_of_group>rosidl_interface_packages</member_of_group> <test_depend>ament_lint_auto</test_depend> <test_depend>ament_lint_common</test_depend> <export> <build_type>ament_cmake</build_type> </export> </package>","title":"Modify the package.xml file:"},{"location":"ROS2/custom_interface/#compile-check","text":"cd ~/ros2_ws colcon build --packages-select custom_interfaces source install/setup.bash ros2 interface show custom_interfaces/msg/Age","title":"Compile &amp; Check"},{"location":"ROS2/custom_interface/#example-of-a-use-case","text":"Including ' on_shutdown ' feature import rclpy # import the ROS2 python dependencies from rclpy.node import Node # import the Twist module from geometry_msgs dependencies from geometry_msgs.msg import Twist # import the LaserScan module from sensor_msgs dependencies from sensor_msgs.msg import LaserScan from rclpy.qos import ReliabilityPolicy , QoSProfile from custom_interfaces.msg import Age class Example36 ( Node ): def __init__ ( self ): # Here you have the class constructor # call the class constructor super () . __init__ ( 'example36' ) # create the publisher object self . publisher_ = self . create_publisher ( Twist , 'cmd_vel' , 10 ) # create the subscriber object self . subscriber = self . create_subscription ( LaserScan , '/scan' , self . laser_callback , QoSProfile ( depth = 10 , reliability = ReliabilityPolicy . BEST_EFFORT )) # define the timer period for 0.5 seconds self . timer_period = 0.5 # define the variable to save the received info self . laser_forward = 0 # create a Twist message self . cmd = Twist () self . timer = self . create_timer ( self . timer_period , self . motion ) self . age = Age () def laser_callback ( self , msg ): # Save the frontal laser scan info at 0\u00b0 self . laser_forward = msg . ranges [ 359 ] def motion ( self ): self . get_logger () . info ( 'I receive: \" %s \"' % str ( self . laser_forward )) # Read the first distance until you find a wall if self . laser_forward > 5 : self . cmd . linear . x = 0.5 self . cmd . angular . z = 0.5 # Wall found. It is time to go straight elif self . laser_forward < 5 and self . laser_forward >= 0.5 : self . cmd . linear . x = 0.2 self . cmd . angular . z = 0.0 # be careful if you have to stop. else : self . cmd . linear . x = 0.0 self . cmd . angular . z = 0.0 self . publisher_ . publish ( self . cmd ) def on_shutdown ( self ): self . age . year = 2021 self . age . month = 5 self . age . day = 21 self . get_logger () . info ( 'Date this program was made : %d ' % self . age . day + '/ %d ' % self . age . month + '/ %d ' % self . age . year ) def main ( args = None ): # initialize the ROS communication rclpy . init ( args = args ) # declare the node constructor example36 = Example36 () # pause the program execution, waits for a request to kill the node (ctrl+c) rclpy . get_default_context () . on_shutdown ( example36 . on_shutdown ) try : rclpy . spin ( example36 ) except KeyboardInterrupt : pass # shutdown the ROS communication rclpy . shutdown () if __name__ == '__main__' : main ()","title":"Example of a use case:"},{"location":"ROS2/custom_interface/#create-cusom-service-interface","text":"cd ~/ros2_ws/src/custom_interfaces mkdir srv cd srv touch MyCustomServiceMessage.srv - The file 'MyCustomServiceMessage.srv' will contain the following: string move # Signal to define the movement # \"Turn right\" to make the robot turn in the right direction. # \"Turn left\" to make the robot turn in the left direction. # \"Stop\" to make the robot stop the movement. --- bool success # Did it achieve it? - modify CMakeLists.txt & package.xml (like on message example) - build and check for this new interface (show) ros2 interface show custom_interfaces/srv/MyCustomServiceMessage","title":"Create cusom service interface"},{"location":"ROS2/custom_interface/#example-of-a-use-case_1","text":"Create a new package named movement_pkg on your ~/ros2_ws/src directory. cd ~/ros2_ws/src ros2 pkg create --build-type ament_python movement_pkg --dependencies rclpy custom_interfaces std_msgs geometry_msgs sensor_msgs Create two new files named movement_server.py and movement_client.py inside the movement_pkg folder Inside the file movement_server.py, write the following code: # import the Twist module from geometry_msgs messages interface from geometry_msgs.msg import Twist # import the MyCustomServiceMessage module from custom_interfaces_service interface from custom_interfaces.srv import MyCustomServiceMessage # import the ROS2 Python client libraries import rclpy from rclpy.node import Node class Service ( Node ): def __init__ ( self ): # Here you have the class constructor # call the class constructor to initialize the node as service_stop super () . __init__ ( 'movement_server' ) # create the Service Server object # defines the type, name, and callback function self . srv = self . create_service ( MyCustomServiceMessage , 'movement' , self . custom_service_callback ) # create the Publisher object # in this case, the Publisher will publish on /cmd_vel topic with a queue size of 10 messages. # use the Twist module self . publisher_ = self . create_publisher ( Twist , 'cmd_vel' , 10 ) def custom_service_callback ( self , request , response ): # The callback function receives the self-class parameter, # received along with two parameters called request and response # - receive the data by request # - return a result as a response # create a Twist message msg = Twist () if request . move == \"Turn Right\" : # define the linear x-axis velocity of /cmd_vel topic parameter to 0.1 msg . linear . x = 0.1 # define the angular z-axis velocity of /cmd_vel topic parameter to -0.5 to turn right msg . angular . z = - 0.5 # Publish the message to the topic self . publisher_ . publish ( msg ) # print a pretty message self . get_logger () . info ( 'Turning to right direction!!' ) # response state response . success = True elif request . move == \"Turn Left\" : # define the linear x-axis velocity of /cmd_vel topic parameter to 0.1 msg . linear . x = 0.1 # define the angular z-axis velocity of /cmd_vel topic parameter to 0.5 to turn left msg . angular . z = 0.5 # Publish the message to the topic self . publisher_ . publish ( msg ) # print a pretty message self . get_logger () . info ( 'Turning to left direction!!' ) # response state response . success = True elif request . move == \"Stop\" : # define the linear x-axis velocity of /cmd_vel topic parameter to 0 msg . linear . x = 0.0 # define the angular z-axis velocity of /cmd_vel topic parameter to 0 msg . angular . z = 0.0 # Publish the message to the topic self . publisher_ . publish ( msg ) # print a pretty message self . get_logger () . info ( 'Stop there!!' ) # response state response . success = True else : # response state response . success = False # return the response parameter return response def main ( args = None ): # initialize the ROS communication rclpy . init ( args = args ) # declare the node constructor service = Service () # pause the program execution, waits for a request to kill the node (ctrl+c) rclpy . spin ( service ) # shutdown the ROS communication rclpy . shutdown () if __name__ == '__main__' : main () Inside the file movement_client.py write the following code: # import the MyCustomServiceMessage module from custom_interfaces_service interface from custom_interfaces.srv import MyCustomServiceMessage # import the ROS2 Python client libraries import rclpy from rclpy.node import Node import sys class ClientAsync ( Node ): def __init__ ( self ): # Here you have the class constructor # call the class constructor to initialize the node as movement_client super () . __init__ ( 'movement_client' ) # create the Service Client object # defines the name and type of the Service Server you will work with. self . client = self . create_client ( MyCustomServiceMessage , 'movement' ) # checks once per second if a Service matching the type and name of the client is available. while not self . client . wait_for_service ( timeout_sec = 1.0 ): # if it is not available, a message is displayed self . get_logger () . info ( 'service not available, waiting again...' ) # create an Empty request self . req = MyCustomServiceMessage . Request () def send_request ( self ): # send the request self . req . move = sys . argv [ 1 ] # uses sys.argv to access command line input arguments for the request. self . future = self . client . call_async ( self . req ) # to print in the console def main ( args = None ): # initialize the ROS communication rclpy . init ( args = args ) # declare the node constructor client = ClientAsync () # run the send_request() method client . send_request () while rclpy . ok (): # pause the program execution, waits for a request to kill the node (ctrl+c) rclpy . spin_once ( client ) if client . future . done (): try : # checks the future for a response from the Service # while the system is running. # if the Service has sent a response, the result will be written # to a log message. response = client . future . result () except Exception as e : # Display the message on the console client . get_logger () . info ( 'Service call failed %r ' % ( e ,)) else : # Display the message on the console client . get_logger () . info ( 'Response state %r ' % ( response . success ,)) break client . destroy_node () # shutdown the ROS communication rclpy . shutdown () if __name__ == '__main__' : main () Create a launch file named movement_server_launch_file.launch.py to launch the Service Server node you just created. cd ~/ros2_ws/src/movement_pkg mkdir launch cd launch touch movement_server_launch_file.launch.py Inside movement_server_launch_file.launch.py, write the necessary code to launch the executable files of the movement_server script. from launch import LaunchDescription from launch_ros.actions import Node def generate_launch_description (): return LaunchDescription ([ Node ( package = 'movement_pkg' , executable = 'movement_server' , output = 'screen' ), ]) Modify the setup.py from setuptools import setup import os from glob import glob package_name = 'movement_pkg' setup ( name = package_name , version = '0.0.0' , packages = [ package_name ], data_files = [ ( 'share/ament_index/resource_index/packages' , [ 'resource/' + package_name ]), ( 'share/' + package_name , [ 'package.xml' ]), ( os . path . join ( 'share' , package_name ), glob ( 'launch/*.launch.py' )) ], install_requires = [ 'setuptools' ], zip_safe = True , maintainer = 'user' , maintainer_email = 'user@todo.todo' , description = 'TODO: Package description' , license = 'TODO: License declaration' , tests_require = [ 'pytest' ], entry_points = { 'console_scripts' : [ 'movement_server = movement_pkg.movement_server:main' , 'movement_client = movement_pkg.movement_client:main' ], }, ) Compile your package Launch the Service Server ros2 launch movement_pkg movement_server_launch_file.launch.py on a different shell, play with the client: ros2 run movement_pkg movement_client \"Turn Left\" ros2 run movement_pkg movement_client \"Turn Right\" ros2 run movement_pkg movement_client \"Stop\" ros2 run movement_pkg movement_client \"Invalid\"","title":"Example of a use case:"},{"location":"ROS2/pub%5Csub/","text":"Pub/Sub Simple Publisher Node import rclpy # import the ROS2 python libraries from rclpy.node import Node # import the Twist interface from the geometry_msgs package from geometry_msgs.msg import Twist class SimplePublisher ( Node ): def __init__ ( self ): # Here you have the class constructor # call super() in the constructor to initialize the Node object # the parameter you pass is the node name super () . __init__ ( 'simple_publisher' ) # create the publisher object # in this case, the publisher will publish on /cmd_vel Topic with a queue size of 10 messages. # use the Twist module for /cmd_vel Topic self . publisher_ = self . create_publisher ( Twist , 'cmd_vel' , 10 ) # define the timer period for 0.5 seconds timer_period = 0.5 # create a timer sending two parameters: # - the duration between 2 callbacks (0.5 seconds) # - the timer function (timer_callback) self . timer = self . create_timer ( timer_period , self . timer_callback ) def timer_callback ( self ): # Here you have the callback method # create a Twist message msg = Twist () # define the linear x-axis velocity of /cmd_vel Topic parameter to 0.5 msg . linear . x = 0.5 # define the angular z-axis velocity of /cmd_vel Topic parameter to 0.5 msg . angular . z = 0.5 # Publish the message to the Topic self . publisher_ . publish ( msg ) # Display the message on the console self . get_logger () . info ( 'Publishing: \" %s \"' % msg ) def main ( args = None ): # initialize the ROS communication rclpy . init ( args = args ) # declare the node constructor simple_publisher = SimplePublisher () # pause the program execution, waits for a request to kill the node (ctrl+c) rclpy . spin ( simple_publisher ) # Explicity destroys the node simple_publisher . destroy_node () # shutdown the ROS communication rclpy . shutdown () if __name__ == '__main__' : main () Simple Subscriber Node import rclpy # import the ROS2 python libraries from rclpy.node import Node # import the LaserScan module from sensor_msgs interface from sensor_msgs.msg import LaserScan # import Quality of Service library, to set the correct profile and reliability to read sensor data. from rclpy.qos import ReliabilityPolicy , QoSProfile class SimpleSubscriber ( Node ): def __init__ ( self ): # Here you have the class constructor # call super() in the constructor to initialize the Node object # the parameter you pass is the node name super () . __init__ ( 'simple_subscriber' ) # create the subscriber object # in this case, the subscriptor will be subscribed on /scan topic with a queue size of 10 messages. # use the LaserScan module for /scan topic # send the received info to the listener_callback method. self . subscriber = self . create_subscription ( LaserScan , '/scan' , self . listener_callback , QoSProfile ( depth = 10 , reliability = ReliabilityPolicy . BEST_EFFORT )) # is the most used to read LaserScan data and some sensor data. def listener_callback ( self , msg ): # print the log info in the terminal self . get_logger () . info ( 'I receive: \" %s \"' % str ( msg )) def main ( args = None ): # initialize the ROS communication rclpy . init ( args = args ) # declare the node constructor simple_subscriber = SimpleSubscriber () # pause the program execution, waits for a request to kill the node (ctrl+c) rclpy . spin ( simple_subscriber ) # Explicity destroy the node simple_subscriber . destroy_node () # shutdown the ROS communication rclpy . shutdown () if __name__ == '__main__' : main () Simple Publisher & Subscriber Node import rclpy # import the ROS2 python libraries from rclpy.node import Node # import the Twist module from geometry_msgs interface from geometry_msgs.msg import Twist # import the LaserScan module from sensor_msgs interface from sensor_msgs.msg import LaserScan from rclpy.qos import ReliabilityPolicy , QoSProfile class Exercise31 ( Node ): def __init__ ( self ): # Here you have the class constructor # call the class constructor super () . __init__ ( 'exercise31' ) # create the publisher object self . publisher_ = self . create_publisher ( Twist , 'cmd_vel' , 10 ) # create the subscriber object self . subscriber = self . create_subscription ( LaserScan , '/scan' , self . laser_callback , QoSProfile ( depth = 10 , reliability = ReliabilityPolicy . BEST_EFFORT )) # define the timer period for 0.5 seconds self . timer_period = 0.5 # define the variable to save the received info self . laser_forward = 0 # create a Twist message self . cmd = Twist () self . timer = self . create_timer ( self . timer_period , self . motion ) def laser_callback ( self , msg ): # Save the frontal laser scan info at 0\u00b0 self . laser_forward = msg . ranges [ 359 ] def motion ( self ): # print the data self . get_logger () . info ( 'I receive: \" %s \"' % str ( self . laser_forward )) # Logic of move if self . laser_forward > 5 : self . cmd . linear . x = 0.5 self . cmd . angular . z = 0.5 elif self . laser_forward < 5 and self . laser_forward >= 0.5 : self . cmd . linear . x = 0.2 self . cmd . angular . z = 0.0 else : self . cmd . linear . x = 0.0 self . cmd . angular . z = 0.0 # Publishing the cmd_vel values to a Topic self . publisher_ . publish ( self . cmd ) def main ( args = None ): # initialize the ROS communication rclpy . init ( args = args ) # declare the node constructor exercise31 = Exercise31 () # pause the program execution, waits for a request to kill the node (ctrl+c) rclpy . spin ( exercise31 ) # Explicity destroy the node exercise31 . destroy_node () # shutdown the ROS communication rclpy . shutdown () if __name__ == '__main__' : main ()","title":"Pub/Sub"},{"location":"ROS2/pub%5Csub/#pubsub","text":"","title":"Pub/Sub"},{"location":"ROS2/pub%5Csub/#simple-publisher-node","text":"import rclpy # import the ROS2 python libraries from rclpy.node import Node # import the Twist interface from the geometry_msgs package from geometry_msgs.msg import Twist class SimplePublisher ( Node ): def __init__ ( self ): # Here you have the class constructor # call super() in the constructor to initialize the Node object # the parameter you pass is the node name super () . __init__ ( 'simple_publisher' ) # create the publisher object # in this case, the publisher will publish on /cmd_vel Topic with a queue size of 10 messages. # use the Twist module for /cmd_vel Topic self . publisher_ = self . create_publisher ( Twist , 'cmd_vel' , 10 ) # define the timer period for 0.5 seconds timer_period = 0.5 # create a timer sending two parameters: # - the duration between 2 callbacks (0.5 seconds) # - the timer function (timer_callback) self . timer = self . create_timer ( timer_period , self . timer_callback ) def timer_callback ( self ): # Here you have the callback method # create a Twist message msg = Twist () # define the linear x-axis velocity of /cmd_vel Topic parameter to 0.5 msg . linear . x = 0.5 # define the angular z-axis velocity of /cmd_vel Topic parameter to 0.5 msg . angular . z = 0.5 # Publish the message to the Topic self . publisher_ . publish ( msg ) # Display the message on the console self . get_logger () . info ( 'Publishing: \" %s \"' % msg ) def main ( args = None ): # initialize the ROS communication rclpy . init ( args = args ) # declare the node constructor simple_publisher = SimplePublisher () # pause the program execution, waits for a request to kill the node (ctrl+c) rclpy . spin ( simple_publisher ) # Explicity destroys the node simple_publisher . destroy_node () # shutdown the ROS communication rclpy . shutdown () if __name__ == '__main__' : main ()","title":"Simple Publisher Node"},{"location":"ROS2/pub%5Csub/#simple-subscriber-node","text":"import rclpy # import the ROS2 python libraries from rclpy.node import Node # import the LaserScan module from sensor_msgs interface from sensor_msgs.msg import LaserScan # import Quality of Service library, to set the correct profile and reliability to read sensor data. from rclpy.qos import ReliabilityPolicy , QoSProfile class SimpleSubscriber ( Node ): def __init__ ( self ): # Here you have the class constructor # call super() in the constructor to initialize the Node object # the parameter you pass is the node name super () . __init__ ( 'simple_subscriber' ) # create the subscriber object # in this case, the subscriptor will be subscribed on /scan topic with a queue size of 10 messages. # use the LaserScan module for /scan topic # send the received info to the listener_callback method. self . subscriber = self . create_subscription ( LaserScan , '/scan' , self . listener_callback , QoSProfile ( depth = 10 , reliability = ReliabilityPolicy . BEST_EFFORT )) # is the most used to read LaserScan data and some sensor data. def listener_callback ( self , msg ): # print the log info in the terminal self . get_logger () . info ( 'I receive: \" %s \"' % str ( msg )) def main ( args = None ): # initialize the ROS communication rclpy . init ( args = args ) # declare the node constructor simple_subscriber = SimpleSubscriber () # pause the program execution, waits for a request to kill the node (ctrl+c) rclpy . spin ( simple_subscriber ) # Explicity destroy the node simple_subscriber . destroy_node () # shutdown the ROS communication rclpy . shutdown () if __name__ == '__main__' : main ()","title":"Simple Subscriber Node"},{"location":"ROS2/pub%5Csub/#simple-publisher-subscriber-node","text":"import rclpy # import the ROS2 python libraries from rclpy.node import Node # import the Twist module from geometry_msgs interface from geometry_msgs.msg import Twist # import the LaserScan module from sensor_msgs interface from sensor_msgs.msg import LaserScan from rclpy.qos import ReliabilityPolicy , QoSProfile class Exercise31 ( Node ): def __init__ ( self ): # Here you have the class constructor # call the class constructor super () . __init__ ( 'exercise31' ) # create the publisher object self . publisher_ = self . create_publisher ( Twist , 'cmd_vel' , 10 ) # create the subscriber object self . subscriber = self . create_subscription ( LaserScan , '/scan' , self . laser_callback , QoSProfile ( depth = 10 , reliability = ReliabilityPolicy . BEST_EFFORT )) # define the timer period for 0.5 seconds self . timer_period = 0.5 # define the variable to save the received info self . laser_forward = 0 # create a Twist message self . cmd = Twist () self . timer = self . create_timer ( self . timer_period , self . motion ) def laser_callback ( self , msg ): # Save the frontal laser scan info at 0\u00b0 self . laser_forward = msg . ranges [ 359 ] def motion ( self ): # print the data self . get_logger () . info ( 'I receive: \" %s \"' % str ( self . laser_forward )) # Logic of move if self . laser_forward > 5 : self . cmd . linear . x = 0.5 self . cmd . angular . z = 0.5 elif self . laser_forward < 5 and self . laser_forward >= 0.5 : self . cmd . linear . x = 0.2 self . cmd . angular . z = 0.0 else : self . cmd . linear . x = 0.0 self . cmd . angular . z = 0.0 # Publishing the cmd_vel values to a Topic self . publisher_ . publish ( self . cmd ) def main ( args = None ): # initialize the ROS communication rclpy . init ( args = args ) # declare the node constructor exercise31 = Exercise31 () # pause the program execution, waits for a request to kill the node (ctrl+c) rclpy . spin ( exercise31 ) # Explicity destroy the node exercise31 . destroy_node () # shutdown the ROS communication rclpy . shutdown () if __name__ == '__main__' : main ()","title":"Simple Publisher &amp; Subscriber Node"},{"location":"ROS2/services/","text":"Services Basic commands Working with Services, you will have two sides: Clients and Servers. You can have multiple Clients using the same Service Server, but you can only have one Server for one Service. ros2 service list ros2 service type <service_name> ros2 interface show <service_type> ros2 service call <service_name> <service_type> <value> Create a client (/moving) # import the empty module from std_servs Service interface from std_srvs.srv import Empty # import the ROS2 Python client libraries import rclpy from rclpy.node import Node class ClientAsync ( Node ): def __init__ ( self ): # Here you have the class constructor # call the class constructor to initialize the node as service_client super () . __init__ ( 'service_client' ) # create the Service Client object # defines the name and type of the Service Server you will work with. self . client = self . create_client ( Empty , 'moving' ) # checks once per second if a Service matching the type and name of the Client is available. while not self . client . wait_for_service ( timeout_sec = 1.0 ): # if it is not available, a message is displayed self . get_logger () . info ( 'service not available, waiting again...' ) # create an Empty request self . req = Empty . Request () def send_request ( self ): # send the request self . future = self . client . call_async ( self . req ) def main ( args = None ): # initialize the ROS communication rclpy . init ( args = args ) # declare the node constructor client = ClientAsync () # run the send_request() method client . send_request () while rclpy . ok (): # pause the program execution, waits for a request to kill the node (ctrl+c) rclpy . spin_once ( client ) if client . future . done (): try : # checks the future for a response from the Service # while the system is running. # If the Service has sent a response, the result will be written # to a log message. response = client . future . result () except Exception as e : # Display the message on the console client . get_logger () . info ( 'Service call failed %r ' % ( e ,)) else : # Display the message on the console client . get_logger () . info ( 'the robot is moving' ) break client . destroy_node () # shutdown the ROS communication rclpy . shutdown () if __name__ == '__main__' : main () Create a server (/moving_right) # import the SetBool module from std_servs Service interface from std_srvs.srv import SetBool # import the Twist module from geometry_msgs messages interface from geometry_msgs.msg import Twist # import the ROS2 Python client libraries import rclpy from rclpy.node import Node class Service ( Node ): def __init__ ( self ): # Here you have the class constructor # call the class constructor to initialize the node as service_moving super () . __init__ ( 'service_moving_right' ) # create the Service Server object # defines the type, name, and callback function self . srv = self . create_service ( SetBool , 'moving_right' , self . SetBool_callback ) # create the Publisher object # in this case, the Publisher will publish on /cmd_vel topic with a queue size of 10 messages. # use the Twist module self . publisher_ = self . create_publisher ( Twist , 'cmd_vel' , 10 ) # create a Twist message self . cmd = Twist () def SetBool_callback ( self , request , response ): # The callback function receives the self-class parameter, # received along with two parameters called request and response # - receive the data by request # - return a result as a response # Publish the message to the topic # As you see, the name of the request parameter is data, so do it if request . data == True : # define the linear x-axis velocity of /cmd_vel topic parameter to 0.3 self . cmd . linear . x = 0.3 # define the angular z-axis velocity of /cmd_vel topic parameter to 0.3 self . cmd . angular . z =- 0.3 self . publisher_ . publish ( self . cmd ) # You need a response response . success = True # You need another response, but this time, SetBool lets you put a String response . message = 'MOVING TO THE RIGHT RIGHT RIGHT!' if request . data == False : self . cmd . linear . x = 0.0 # define the angular z-axis velocity of /cmd_vel topic parameter to 0.3 self . cmd . angular . z = 0.0 self . publisher_ . publish ( self . cmd ) response . success = False response . message = 'It is time to stop!' # return the response parameters return response def main ( args = None ): # initialize the ROS communication rclpy . init ( args = args ) # declare the node constructor moving_right_service = Service () # pause the program execution, waits for a request to kill the node (ctrl+c) rclpy . spin ( moving_right_service ) # shutdown the ROS communication rclpy . shutdown () if __name__ == '__main__' : main () Check from cmd_line only after build and launch ... ros2 service call /moving_right std_srvs/srv/SetBool data: \\ true Basic structure of synchronous # initialize the ROS communication rclpy . init ( args = args ) # declare the node constructor client = ClientSync () # start the communication thread spin_thread = Thread ( target = rclpy . spin , args = ( client ,)) spin_thread . start () # run the send_request() method response = client . send_request () # Display the message on the console client . get_logger () . info ( 'Pretty message' ) minimal_client . destroy_node () # shutdown the ROS communication rclpy . shutdown ()","title":"Services"},{"location":"ROS2/services/#services","text":"","title":"Services"},{"location":"ROS2/services/#basic-commands","text":"Working with Services, you will have two sides: Clients and Servers. You can have multiple Clients using the same Service Server, but you can only have one Server for one Service. ros2 service list ros2 service type <service_name> ros2 interface show <service_type> ros2 service call <service_name> <service_type> <value>","title":"Basic commands"},{"location":"ROS2/services/#create-a-client-moving","text":"# import the empty module from std_servs Service interface from std_srvs.srv import Empty # import the ROS2 Python client libraries import rclpy from rclpy.node import Node class ClientAsync ( Node ): def __init__ ( self ): # Here you have the class constructor # call the class constructor to initialize the node as service_client super () . __init__ ( 'service_client' ) # create the Service Client object # defines the name and type of the Service Server you will work with. self . client = self . create_client ( Empty , 'moving' ) # checks once per second if a Service matching the type and name of the Client is available. while not self . client . wait_for_service ( timeout_sec = 1.0 ): # if it is not available, a message is displayed self . get_logger () . info ( 'service not available, waiting again...' ) # create an Empty request self . req = Empty . Request () def send_request ( self ): # send the request self . future = self . client . call_async ( self . req ) def main ( args = None ): # initialize the ROS communication rclpy . init ( args = args ) # declare the node constructor client = ClientAsync () # run the send_request() method client . send_request () while rclpy . ok (): # pause the program execution, waits for a request to kill the node (ctrl+c) rclpy . spin_once ( client ) if client . future . done (): try : # checks the future for a response from the Service # while the system is running. # If the Service has sent a response, the result will be written # to a log message. response = client . future . result () except Exception as e : # Display the message on the console client . get_logger () . info ( 'Service call failed %r ' % ( e ,)) else : # Display the message on the console client . get_logger () . info ( 'the robot is moving' ) break client . destroy_node () # shutdown the ROS communication rclpy . shutdown () if __name__ == '__main__' : main ()","title":"Create a client (/moving)"},{"location":"ROS2/services/#create-a-server-moving_right","text":"# import the SetBool module from std_servs Service interface from std_srvs.srv import SetBool # import the Twist module from geometry_msgs messages interface from geometry_msgs.msg import Twist # import the ROS2 Python client libraries import rclpy from rclpy.node import Node class Service ( Node ): def __init__ ( self ): # Here you have the class constructor # call the class constructor to initialize the node as service_moving super () . __init__ ( 'service_moving_right' ) # create the Service Server object # defines the type, name, and callback function self . srv = self . create_service ( SetBool , 'moving_right' , self . SetBool_callback ) # create the Publisher object # in this case, the Publisher will publish on /cmd_vel topic with a queue size of 10 messages. # use the Twist module self . publisher_ = self . create_publisher ( Twist , 'cmd_vel' , 10 ) # create a Twist message self . cmd = Twist () def SetBool_callback ( self , request , response ): # The callback function receives the self-class parameter, # received along with two parameters called request and response # - receive the data by request # - return a result as a response # Publish the message to the topic # As you see, the name of the request parameter is data, so do it if request . data == True : # define the linear x-axis velocity of /cmd_vel topic parameter to 0.3 self . cmd . linear . x = 0.3 # define the angular z-axis velocity of /cmd_vel topic parameter to 0.3 self . cmd . angular . z =- 0.3 self . publisher_ . publish ( self . cmd ) # You need a response response . success = True # You need another response, but this time, SetBool lets you put a String response . message = 'MOVING TO THE RIGHT RIGHT RIGHT!' if request . data == False : self . cmd . linear . x = 0.0 # define the angular z-axis velocity of /cmd_vel topic parameter to 0.3 self . cmd . angular . z = 0.0 self . publisher_ . publish ( self . cmd ) response . success = False response . message = 'It is time to stop!' # return the response parameters return response def main ( args = None ): # initialize the ROS communication rclpy . init ( args = args ) # declare the node constructor moving_right_service = Service () # pause the program execution, waits for a request to kill the node (ctrl+c) rclpy . spin ( moving_right_service ) # shutdown the ROS communication rclpy . shutdown () if __name__ == '__main__' : main ()","title":"Create a server (/moving_right)"},{"location":"ROS2/services/#check-from-cmd_line","text":"only after build and launch ... ros2 service call /moving_right std_srvs/srv/SetBool data: \\ true","title":"Check from cmd_line"},{"location":"ROS2/services/#basic-structure-of-synchronous","text":"# initialize the ROS communication rclpy . init ( args = args ) # declare the node constructor client = ClientSync () # start the communication thread spin_thread = Thread ( target = rclpy . spin , args = ( client ,)) spin_thread . start () # run the send_request() method response = client . send_request () # Display the message on the console client . get_logger () . info ( 'Pretty message' ) minimal_client . destroy_node () # shutdown the ROS communication rclpy . shutdown ()","title":"Basic structure of synchronous"},{"location":"ROS2/simulation/","text":"Simulation Run simulator source /opt/ros/noetic/setup.bash source ~/simulation_ws/devel/setup.bash roslaunch realrobotlab main.launch Ros1 Bridge source ~/catkin_ws/devel/setup.bash roslaunch load_params load_params.launch source /opt/ros/foxy/setup.bash ros2 run ros1_bridge parameter_bridge","title":"Simulation"},{"location":"ROS2/simulation/#simulation","text":"","title":"Simulation"},{"location":"ROS2/simulation/#run-simulator","text":"source /opt/ros/noetic/setup.bash source ~/simulation_ws/devel/setup.bash roslaunch realrobotlab main.launch","title":"Run simulator"},{"location":"ROS2/simulation/#ros1-bridge","text":"source ~/catkin_ws/devel/setup.bash roslaunch load_params load_params.launch source /opt/ros/foxy/setup.bash ros2 run ros1_bridge parameter_bridge","title":"Ros1 Bridge"},{"location":"Ubuntu/apt/","text":"How to use Update (do it repeatly): sudo apt update Search: apt search [package_name] install package: sudo apt install [package_name]","title":"Apt"},{"location":"Ubuntu/apt/#how-to-use","text":"Update (do it repeatly): sudo apt update Search: apt search [package_name] install package: sudo apt install [package_name]","title":"How to use"},{"location":"Ubuntu/file_%20system/","text":"","title":"File  system"},{"location":"Ubuntu/installation/","text":"","title":"Installation"},{"location":"Ubuntu/network/","text":"","title":"Network"}]}